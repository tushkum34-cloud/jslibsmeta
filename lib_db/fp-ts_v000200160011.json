{
  "altAll": [
    "F"
  ],
  "getAlternativeMonoid": [
    "F"
  ],
  "getApplicativeMonoid": [
    "F"
  ],
  "getApplicativeComposition": [
    "F",
    "G"
  ],
  "ap": [
    "F"
  ],
  "apFirst": [
    "A"
  ],
  "apSecond": [
    "A"
  ],
  "apS": [
    "F"
  ],
  "getApplySemigroup": [
    "F"
  ],
  "curried": [
    "f",
    "n",
    "acc"
  ],
  "getTupleConstructor": [
    "len"
  ],
  "sequenceT": [
    "F"
  ],
  "getRecordConstructor": [
    "keys"
  ],
  "sequenceS": [
    "F"
  ],
  "isEmpty": [
    "s"
  ],
  "makeBy": [
    "f"
  ],
  "replicate": [
    "a"
  ],
  "fromPredicate": [
    "predicate",
    "onFalse"
  ],
  "fromOption": [
    "onNone"
  ],
  "fromEither": [
    "ma"
  ],
  "matchW": [
    "onFalse",
    "onTrue"
  ],
  "matchLeftW": [
    "onEmpty",
    "onNonEmpty"
  ],
  "matchRightW": [
    "onEmpty",
    "onNonEmpty"
  ],
  "chainWithIndex": [
    "f"
  ],
  "scanLeft": [
    "b",
    "f"
  ],
  "scanRight": [
    "b",
    "f"
  ],
  "size": [
    "s"
  ],
  "tail": [
    "as"
  ],
  "init": [
    "as"
  ],
  "takeLeft": [
    "n"
  ],
  "takeRight": [
    "n"
  ],
  "takeLeftWhile": [
    "predicate"
  ],
  "spanLeftIndex": [
    "as",
    "predicate"
  ],
  "spanLeft": [
    "predicate"
  ],
  "dropLeft": [
    "n"
  ],
  "dropRight": [
    "n"
  ],
  "dropLeftWhile": [
    "predicate"
  ],
  "findFirst": [
    "predicate"
  ],
  "findLast": [
    "predicate"
  ],
  "copy": [
    "m"
  ],
  "insertAt": [
    "i",
    "a"
  ],
  "updateAt": [
    "k",
    "a"
  ],
  "deleteAt": [
    "k"
  ],
  "modifyAt": [
    "k",
    "f"
  ],
  "reverse": [
    "as"
  ],
  "rights": [
    "as"
  ],
  "lefts": [
    "as"
  ],
  "sort": [
    "O"
  ],
  "zipWith": [
    "as",
    "bs",
    "f"
  ],
  "zip": [
    "as",
    "bs"
  ],
  "unzip": [
    "abs"
  ],
  "prependAll": [
    "middle"
  ],
  "intersperse": [
    "middle"
  ],
  "rotate": [
    "n"
  ],
  "uniq": [
    "E"
  ],
  "sortBy": [
    "ords"
  ],
  "chop": [
    "f"
  ],
  "splitAt": [
    "n"
  ],
  "chunksOf": [
    "n"
  ],
  "fromOptionK": [
    "getOption"
  ],
  "comprehension": [
    "input",
    "f",
    "g"
  ],
  "go": [
    "a",
    "fa"
  ],
  "concatW": [
    "second"
  ],
  "union": [
    "E"
  ],
  "intersection": [
    "E"
  ],
  "difference": [
    "E"
  ],
  "_map": [
    "fa",
    "f"
  ],
  "_mapWithIndex": [
    "fa",
    "f"
  ],
  "_ap": [
    "fab",
    "fa"
  ],
  "_filter": [
    "fa",
    "predicate"
  ],
  "_filterMap": [
    "fa",
    "f"
  ],
  "_partition": [
    "fa",
    "predicate"
  ],
  "_partitionMap": [
    "fa",
    "f"
  ],
  "_partitionWithIndex": [
    "fa",
    "predicateWithIndex"
  ],
  "_partitionMapWithIndex": [
    "fa",
    "f"
  ],
  "_alt": [
    "fa",
    "that"
  ],
  "_reduce": [
    "fa",
    "b",
    "f"
  ],
  "_foldMap": [
    "M"
  ],
  "_reduceRight": [
    "fa",
    "b",
    "f"
  ],
  "_reduceWithIndex": [
    "O"
  ],
  "_foldMapWithIndex": [
    "O"
  ],
  "_reduceRightWithIndex": [
    "O"
  ],
  "_filterMapWithIndex": [
    "fa",
    "f"
  ],
  "_filterWithIndex": [
    "fa",
    "predicateWithIndex"
  ],
  "_extend": [
    "wa",
    "f"
  ],
  "_traverse": [
    "F"
  ],
  "_traverseWithIndex": [
    "O"
  ],
  "zero": [],
  "map": [
    "F"
  ],
  "mapWithIndex": [
    "F"
  ],
  "filterMapWithIndex": [
    "F"
  ],
  "filterMap": [
    "F"
  ],
  "separate": [
    "EE",
    "EA"
  ],
  "filter": [
    "F"
  ],
  "partition": [
    "F"
  ],
  "partitionWithIndex": [
    "F"
  ],
  "partitionMap": [
    "F"
  ],
  "partitionMapWithIndex": [
    "F"
  ],
  "altW": [
    "that"
  ],
  "filterWithIndex": [
    "F"
  ],
  "extend": [
    "F"
  ],
  "traverse": [
    "F"
  ],
  "sequence": [
    "F"
  ],
  "traverseWithIndex": [
    "F"
  ],
  "wither": [
    "F"
  ],
  "wilt": [
    "F"
  ],
  "unfold": [
    "b",
    "f"
  ],
  "getSemigroup": [
    "S"
  ],
  "getMonoid": [
    "M"
  ],
  "getUnionSemigroup": [
    "E"
  ],
  "getUnionMonoid": [
    "E"
  ],
  "getIntersectionSemigroup": [
    "E"
  ],
  "getDifferenceMagma": [
    "E"
  ],
  "unsafeUpdateAt": [
    "i",
    "a",
    "as"
  ],
  "unsafeDeleteAt": [
    "i",
    "as"
  ],
  "some": [
    "a"
  ],
  "clamp": [
    "O"
  ],
  "getMinMaxBoundedDistributiveLattice": [
    "O"
  ],
  "chainFirst": [
    "M"
  ],
  "tap": [
    "M"
  ],
  "bind": [
    "M"
  ],
  "tailRec": [
    "startWith",
    "f"
  ],
  "split": [
    "separator"
  ],
  "fanIn": [
    "P",
    "C"
  ],
  "splitChoice": [
    "F"
  ],
  "fanin": [
    "F"
  ],
  "compact": [
    "E"
  ],
  "getCompactableComposition": [
    "F",
    "G"
  ],
  "log": [
    "a"
  ],
  "warn": [
    "a"
  ],
  "error": [
    "a"
  ],
  "info": [
    "a"
  ],
  "getShow": [
    "S"
  ],
  "getApply": [
    "S"
  ],
  "getApplicative": [
    "M"
  ],
  "_contramap": [
    "fa",
    "f"
  ],
  "_bimap": [
    "fa",
    "f",
    "g"
  ],
  "_mapLeft": [
    "fa",
    "f"
  ],
  "contramap": [
    "F"
  ],
  "bimap": [
    "F"
  ],
  "mapLeft": [
    "F"
  ],
  "create": [],
  "now": [],
  "getMinMaxDistributiveLattice": [
    "O"
  ],
  "_chainRec": [
    "a",
    "f"
  ],
  "getEq": [
    "E"
  ],
  "getCompactable": [
    "M"
  ],
  "getFilterable": [
    "M"
  ],
  "getWitherable": [
    "O"
  ],
  "getApplicativeValidation": [
    "SE"
  ],
  "getAltValidation": [
    "SE"
  ],
  "apW": [
    "fa"
  ],
  "reduce": [
    "F"
  ],
  "foldMap": [
    "F"
  ],
  "reduceRight": [
    "F"
  ],
  "getOrElseW": [
    "onNone"
  ],
  "swap": [
    "ea"
  ],
  "orElseW": [
    "onLeft"
  ],
  "fromNullable": [
    "F"
  ],
  "tryCatch": [
    "f"
  ],
  "tryCatchK": [
    "f"
  ],
  "fromNullableK": [
    "F"
  ],
  "chainNullableK": [
    "M"
  ],
  "toError": [
    "e"
  ],
  "elem": [
    "E"
  ],
  "exists": [
    "predicate"
  ],
  "traverseReadonlyNonEmptyArrayWithIndex": [
    "S"
  ],
  "traverseReadonlyArrayWithIndex": [
    "S"
  ],
  "traverseArray": [
    "f"
  ],
  "parseJSON": [
    "s",
    "onError"
  ],
  "stringifyJSON": [
    "u",
    "onError"
  ],
  "getValidationSemigroup": [
    "SE",
    "SA"
  ],
  "getValidationMonoid": [
    "SE",
    "MA"
  ],
  "getValidation": [
    "SE"
  ],
  "right": [
    "a"
  ],
  "left": [
    "e"
  ],
  "rightF": [
    "F"
  ],
  "leftF": [
    "F"
  ],
  "chain": [
    "F"
  ],
  "flatMap": [
    "M"
  ],
  "alt": [
    "F"
  ],
  "mapBoth": [
    "F"
  ],
  "mapError": [
    "F"
  ],
  "altValidation": [
    "M",
    "S"
  ],
  "match": [
    "F"
  ],
  "matchE": [
    "M"
  ],
  "getOrElse": [
    "M"
  ],
  "orElse": [
    "M"
  ],
  "orElseFirst": [
    "M"
  ],
  "tapError": [
    "M"
  ],
  "orLeft": [
    "M"
  ],
  "toUnion": [
    "F"
  ],
  "getEitherM": [
    "M"
  ],
  "fromEquals": [
    "equals"
  ],
  "struct": [
    "shows"
  ],
  "tuple": [],
  "contramap_": [
    "predicate",
    "f"
  ],
  "gcd": [
    "E",
    "field"
  ],
  "f": [
    "x",
    "y"
  ],
  "lcm": [
    "E",
    "F"
  ],
  "getFilterableComposition": [
    "F",
    "G"
  ],
  "reduceM": [
    "M",
    "F"
  ],
  "intercalate": [
    "middle"
  ],
  "toReadonlyArray": [
    "O"
  ],
  "traverse_": [
    "M",
    "F"
  ],
  "applyFirst": [
    "mu",
    "mb"
  ],
  "foldM": [
    "M",
    "F"
  ],
  "getFoldableComposition": [
    "F",
    "G"
  ],
  "reduceWithIndex": [
    "F"
  ],
  "foldMapWithIndex": [
    "F"
  ],
  "reduceRightWithIndex": [
    "F"
  ],
  "getFoldableWithIndexComposition": [
    "F",
    "G"
  ],
  "chainOptionK": [
    "M"
  ],
  "fromEitherK": [
    "getEither"
  ],
  "chainEitherK": [
    "F",
    "M"
  ],
  "chainFirstEitherK": [
    "F",
    "M"
  ],
  "filterOrElse": [
    "predicate",
    "onFalse"
  ],
  "tapEither": [
    "F",
    "M"
  ],
  "fromIOK": [
    "F"
  ],
  "chainIOK": [
    "F",
    "M"
  ],
  "chainFirstIOK": [
    "F",
    "M"
  ],
  "tapIO": [
    "F",
    "M"
  ],
  "ask": [],
  "asks": [
    "F"
  ],
  "fromReaderK": [
    "F"
  ],
  "chainReaderK": [
    "F",
    "M"
  ],
  "chainFirstReaderK": [
    "F",
    "M"
  ],
  "tapReader": [
    "F",
    "M"
  ],
  "get": [],
  "put": [
    "s"
  ],
  "modify": [
    "f"
  ],
  "gets": [
    "f"
  ],
  "fromStateK": [
    "F"
  ],
  "chainStateK": [
    "F",
    "M"
  ],
  "fromTaskK": [
    "F"
  ],
  "chainTaskK": [
    "F",
    "M"
  ],
  "chainFirstTaskK": [
    "F",
    "M"
  ],
  "tapTask": [
    "F",
    "M"
  ],
  "fromTheseK": [
    "F"
  ],
  "flap": [
    "F"
  ],
  "bindTo": [
    "F"
  ],
  "let_": [
    "F"
  ],
  "getFunctorComposition": [
    "F",
    "G"
  ],
  "as": [
    "F"
  ],
  "asUnit": [
    "F"
  ],
  "getFunctorWithIndexComposition": [
    "F",
    "G"
  ],
  "orElseFirstIOK": [
    "onLeft"
  ],
  "_apSeq": [
    "fab",
    "fa"
  ],
  "getApplicativeIOValidation": [
    "S"
  ],
  "getAltIOValidation": [
    "S"
  ],
  "bracket": [
    "acquire",
    "use",
    "release"
  ],
  "bracketW": [
    "acquire",
    "use",
    "release"
  ],
  "traverseReadonlyNonEmptyArrayWithIndexSeq": [
    "S"
  ],
  "traverseReadonlyArrayWithIndexSeq": [
    "S"
  ],
  "traverseSeqArray": [
    "f"
  ],
  "getIOValidation": [
    "SE"
  ],
  "IORef": [
    "value"
  ],
  "newIORef": [
    "a"
  ],
  "parse": [
    "s"
  ],
  "stringify": [
    "a"
  ],
  "filterFirst": [
    "predicate"
  ],
  "filterSecond": [
    "predicate"
  ],
  "endo": [
    "f"
  ],
  "concatAll": [
    "S"
  ],
  "keys": [
    "O"
  ],
  "values": [
    "O"
  ],
  "collect": [
    "O"
  ],
  "toArray": [
    "O"
  ],
  "toUnfoldable": [
    "U"
  ],
  "upsertAt": [
    "k",
    "a"
  ],
  "pop": [
    "k"
  ],
  "lookupWithKey": [
    "E"
  ],
  "singleton": [
    "a"
  ],
  "fromFoldable": [
    "M",
    "F"
  ],
  "getFilterableWithIndex": [],
  "getFoldable": [
    "O"
  ],
  "getFoldableWithIndex": [
    "O"
  ],
  "getTraversableWithIndex": [
    "O"
  ],
  "_loop_1": [
    "key"
  ],
  "min": [
    "O"
  ],
  "max": [
    "O"
  ],
  "getEndomorphismMonoid": [],
  "isNonEmpty": [
    "as"
  ],
  "isOutOfBound": [
    "i",
    "as"
  ],
  "prependW": [
    "head"
  ],
  "appendW": [
    "end"
  ],
  "unsafeInsertAt": [
    "i",
    "a",
    "as"
  ],
  "fromArray": [
    "E"
  ],
  "range": [
    "start",
    "end"
  ],
  "unprepend": [
    "as"
  ],
  "unappend": [
    "as"
  ],
  "concat": [
    "x",
    "y"
  ],
  "group": [
    "E"
  ],
  "groupBy": [
    "f"
  ],
  "of": [
    "M"
  ],
  "matchLeft": [
    "f"
  ],
  "matchRight": [
    "f"
  ],
  "modifyHead": [
    "f"
  ],
  "updateHead": [
    "a"
  ],
  "modifyLast": [
    "f"
  ],
  "updateLast": [
    "a"
  ],
  "groupSort": [
    "O"
  ],
  "cons": [
    "head",
    "tail"
  ],
  "snoc": [
    "init",
    "end"
  ],
  "getLeft": [
    "fa"
  ],
  "getRight": [
    "fa"
  ],
  "getOrd": [
    "O"
  ],
  "throwError": [],
  "isNone": [
    "fa"
  ],
  "getRefinement": [
    "getOption"
  ],
  "getFirstMonoid": [],
  "getLastMonoid": [],
  "fromF": [
    "F"
  ],
  "getOptionM": [
    "M"
  ],
  "equalsDefault": [
    "compare"
  ],
  "fromCompare": [
    "compare"
  ],
  "equals": [
    "O"
  ],
  "lt": [
    "O"
  ],
  "gt": [
    "O"
  ],
  "leq": [
    "O"
  ],
  "geq": [
    "O"
  ],
  "between": [
    "O"
  ],
  "compare": [
    "first",
    "second"
  ],
  "sign": [
    "n"
  ],
  "getSemigroupAny": [],
  "getMonoidAny": [],
  "getSemigroupAll": [],
  "getMonoidAll": [],
  "not": [
    "predicate"
  ],
  "or": [
    "second"
  ],
  "and": [
    "second"
  ],
  "random": [],
  "randomInt": [
    "low",
    "high"
  ],
  "randomRange": [
    "min",
    "max"
  ],
  "randomElem": [
    "as"
  ],
  "local": [
    "f"
  ],
  "asksReaderW": [
    "f"
  ],
  "_compose": [
    "bc",
    "ab"
  ],
  "_promap": [
    "fea",
    "f",
    "g"
  ],
  "compose": [
    "F"
  ],
  "promap": [
    "F"
  ],
  "id": [],
  "first": [],
  "second": [
    "pbc"
  ],
  "getApplicativeReaderValidation": [
    "S"
  ],
  "getAltReaderValidation": [
    "S"
  ],
  "getReaderValidation": [
    "SE"
  ],
  "fromReader": [
    "F"
  ],
  "fromNaturalTransformation": [
    "nt"
  ],
  "getReaderM": [
    "M"
  ],
  "_apPar": [
    "fab",
    "fa"
  ],
  "fromReaderIOK": [
    "f"
  ],
  "run": [
    "ma",
    "s",
    "r"
  ],
  "rightReader": [
    "ma"
  ],
  "leftReader": [
    "me"
  ],
  "rightReaderIO": [
    "ma"
  ],
  "leftReaderIO": [
    "me"
  ],
  "fromReaderEither": [
    "ma"
  ],
  "fromIOEitherK": [
    "f"
  ],
  "fromTaskEitherK": [
    "f"
  ],
  "fromReaderEitherK": [
    "f"
  ],
  "getApplicativeReaderTaskValidation": [
    "A",
    "S"
  ],
  "getAltReaderTaskValidation": [
    "S"
  ],
  "fromReaderTaskK": [
    "f"
  ],
  "getReaderTaskValidation": [
    "SE"
  ],
  "lookup": [
    "k",
    "r"
  ],
  "head": [
    "as"
  ],
  "last": [],
  "findIndex": [
    "predicate"
  ],
  "findFirstMap": [
    "f"
  ],
  "findLastMap": [
    "f"
  ],
  "findLastIndex": [
    "predicate"
  ],
  "predicate": [
    "element"
  ],
  "_chainRecDepthFirst": [
    "a",
    "f"
  ],
  "_chainRecBreadthFirst": [
    "a",
    "f"
  ],
  "chainRecDepthFirst": [
    "f"
  ],
  "chainRecBreadthFirst": [
    "f"
  ],
  "every": [
    "predicate"
  ],
  "fromMap": [
    "m"
  ],
  "toMap": [
    "m"
  ],
  "member": [
    "E"
  ],
  "isSubmap": [
    "SK",
    "SA"
  ],
  "getFunctorWithIndex": [],
  "getTraversable": [
    "O"
  ],
  "fromReadonlyArray": [
    "E"
  ],
  "fromRecord": [
    "r"
  ],
  "toRecord": [
    "r"
  ],
  "keys_": [
    "O"
  ],
  "has": [
    "k",
    "r"
  ],
  "isSubrecord": [
    "E"
  ],
  "fromFoldableMap": [
    "M",
    "F"
  ],
  "fromEntries": [
    "fa"
  ],
  "_sequence": [
    "O"
  ],
  "hasOwnProperty": [
    "k",
    "r"
  ],
  "fromSet": [
    "s"
  ],
  "toSet": [
    "s"
  ],
  "insert": [
    "E"
  ],
  "remove": [
    "E"
  ],
  "toggle": [
    "E"
  ],
  "isSubset": [
    "E"
  ],
  "fst": [
    "ea"
  ],
  "snd": [
    "ea"
  ],
  "getChain": [
    "S"
  ],
  "getMonad": [
    "M"
  ],
  "getChainRec": [
    "M"
  ],
  "chainRec": [
    "a",
    "f"
  ],
  "mapFst": [
    "f"
  ],
  "mapSnd": [
    "f"
  ],
  "negate": [
    "R"
  ],
  "constant": [
    "a"
  ],
  "getObjectSemigroup": [],
  "fold": [
    "f"
  ],
  "separated": [
    "left",
    "right"
  ],
  "evaluate": [
    "fa"
  ],
  "execute": [
    "fa"
  ],
  "evalState": [
    "fsa",
    "s"
  ],
  "execState": [
    "fsa",
    "s"
  ],
  "rightTask": [
    "ma"
  ],
  "leftTask": [
    "me"
  ],
  "rightIO": [
    "ma"
  ],
  "leftIO": [
    "me"
  ],
  "rightState": [
    "sa"
  ],
  "leftState": [
    "me"
  ],
  "fromTaskEither": [
    "ma"
  ],
  "fromIOEither": [
    "ma"
  ],
  "asksStateReaderTaskEitherW": [
    "f"
  ],
  "fromReaderTaskEitherK": [
    "f"
  ],
  "chainReaderTaskEitherKW": [
    "f"
  ],
  "fromState": [
    "F"
  ],
  "getStateM": [
    "M"
  ],
  "seek": [
    "s"
  ],
  "seeks": [
    "f"
  ],
  "peeks": [
    "f"
  ],
  "experiment": [
    "F"
  ],
  "extract": [
    "wa"
  ],
  "fanOut": [
    "S",
    "C"
  ],
  "splitStrong": [
    "F"
  ],
  "fanout": [
    "F"
  ],
  "fromIO": [
    "ma"
  ],
  "delay": [
    "millis"
  ],
  "getRaceMonoid": [],
  "never": [],
  "adopt": [
    "value"
  ],
  "fulfilled": [
    "value"
  ],
  "rejected": [
    "value"
  ],
  "step": [
    "op"
  ],
  "verb": [
    "n"
  ],
  "fromTaskOption": [
    "onNone"
  ],
  "orElseFirstTaskK": [
    "onLeft"
  ],
  "fromTaskOptionK": [
    "onNone"
  ],
  "chainTaskOptionKW": [
    "onNone"
  ],
  "getApplicativeTaskValidation": [
    "A",
    "S"
  ],
  "getAltTaskValidation": [
    "S"
  ],
  "taskify": [
    "f"
  ],
  "cbResolver": [
    "e",
    "r"
  ],
  "getTaskValidation": [
    "SE"
  ],
  "toTuple": [
    "e",
    "a"
  ],
  "isLeft": [
    "ma"
  ],
  "isRight": [
    "ma"
  ],
  "isBoth": [
    "fa"
  ],
  "both": [
    "F"
  ],
  "leftOrBoth": [
    "e"
  ],
  "rightOrBoth": [
    "a"
  ],
  "getLeftOnly": [
    "fa"
  ],
  "getRightOnly": [
    "fa"
  ],
  "fromOptions": [
    "fe",
    "fa"
  ],
  "toTuple2": [
    "F"
  ],
  "getTheseM": [
    "M"
  ],
  "mapT": [
    "fa",
    "f"
  ],
  "tracks": [
    "M",
    "f"
  ],
  "listen": [
    "fa"
  ],
  "listens": [
    "f"
  ],
  "censor": [
    "f"
  ],
  "getComonad": [
    "monoid"
  ],
  "getTraversableComposition": [
    "F",
    "G"
  ],
  "make": [
    "value",
    "forest"
  ],
  "show": [
    "t"
  ],
  "draw": [
    "indentation",
    "forest"
  ],
  "drawForest": [
    "forest"
  ],
  "drawTree": [
    "tree"
  ],
  "unfoldTree": [
    "b",
    "f"
  ],
  "unfoldForest": [
    "bs",
    "f"
  ],
  "unfoldTreeM": [
    "M"
  ],
  "unfoldForestM": [
    "M"
  ],
  "out": [
    "f"
  ],
  "getValidationM": [
    "S",
    "M"
  ],
  "wiltDefault": [
    "T",
    "C"
  ],
  "witherDefault": [
    "T",
    "C"
  ],
  "filterE": [
    "W"
  ],
  "tell": [
    "w"
  ],
  "pass": [
    "fa"
  ],
  "getPointed": [
    "M"
  ],
  "evalWriter": [
    "fa"
  ],
  "execWriter": [
    "fa"
  ],
  "getWriterM": [
    "M"
  ],
  "guard": [
    "F",
    "P"
  ],
  "isBoolean": [
    "u"
  ],
  "getBooleanAlgebra": [
    "B"
  ],
  "getSemiring": [
    "S"
  ],
  "getRing": [
    "R"
  ],
  "apply": [
    "a"
  ],
  "identity": [
    "a"
  ],
  "flip": [
    "f"
  ],
  "flow": [
    "ab",
    "bc",
    "cd",
    "de",
    "ef",
    "fg",
    "gh",
    "hi",
    "ij"
  ],
  "increment": [
    "n"
  ],
  "decrement": [
    "n"
  ],
  "absurd": [
    "_"
  ],
  "tupled": [
    "f"
  ],
  "untupled": [
    "f"
  ],
  "pipe": [
    "a",
    "ab",
    "bc",
    "cd",
    "de",
    "ef",
    "fg",
    "gh",
    "hi"
  ],
  "SK": [
    "_",
    "b"
  ],
  "dual": [
    "arity",
    "body"
  ],
  "isSome": [
    "fa"
  ],
  "fromReadonlyNonEmptyArray": [
    "as"
  ],
  "liftNullable": [
    "F"
  ],
  "liftOption": [
    "F"
  ],
  "flatMapNullable": [
    "F",
    "M"
  ],
  "flatMapOption": [
    "F",
    "M"
  ],
  "flatMapEither": [
    "F",
    "M"
  ],
  "flatMapIO": [
    "F",
    "M"
  ],
  "flatMapTask": [
    "F",
    "M"
  ],
  "flatMapReader": [
    "F",
    "M"
  ],
  "isNumber": [
    "u"
  ],
  "isFunctor": [
    "I"
  ],
  "isContravariant": [
    "I"
  ],
  "isFunctorWithIndex": [
    "I"
  ],
  "isApply": [
    "I"
  ],
  "isChain": [
    "I"
  ],
  "isBifunctor": [
    "I"
  ],
  "isExtend": [
    "I"
  ],
  "isFoldable": [
    "I"
  ],
  "isFoldableWithIndex": [
    "I"
  ],
  "isAlt": [
    "I"
  ],
  "isCompactable": [
    "I"
  ],
  "isFilterable": [
    "I"
  ],
  "isFilterableWithIndex": [
    "I"
  ],
  "isProfunctor": [
    "I"
  ],
  "isSemigroupoid": [
    "I"
  ],
  "isMonadThrow": [
    "I"
  ],
  "pipeable": [
    "I"
  ],
  "isString": [
    "u"
  ],
  "toUpperCase": [
    "s"
  ],
  "toLowerCase": [
    "s"
  ],
  "replace": [
    "searchValue",
    "replaceValue"
  ],
  "trim": [
    "s"
  ],
  "trimLeft": [
    "s"
  ],
  "trimRight": [
    "s"
  ],
  "slice": [
    "start",
    "end"
  ],
  "includes": [
    "searchString",
    "position"
  ],
  "startsWith": [
    "searchString",
    "position"
  ],
  "endsWith": [
    "searchString",
    "position"
  ],
  "getAssignSemigroup": [],
  "evolve": [
    "transformations"
  ]
}